% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

%\documentclass[12pt,a4paper]{memoir} % for a long document
\documentclass[12pt,a4paper,article]{memoir} % for a short document

\usepackage[utf8]{inputenc} % set input encoding to utf8

%%% PAGE DIMENSIONS
% Set up the paper to be as close as possible to both A4 & letter:
\settrimmedsize{11in}{210mm}{*} % letter = 11in tall; a4 = 210mm wide
\setlength{\trimtop}{0pt}
\setlength{\trimedge}{\stockwidth}
\addtolength{\trimedge}{-\paperwidth}
\settypeblocksize{*}{\lxvchars}{1.618} % we want to the text block to have golden proportionals
\setulmargins{50pt}{*}{*} % 50pt upper margins
\setlrmargins{*}{*}{1.618} % golden ratio again for left/right margins
\setheaderspaces{*}{*}{1.618}
\checkandfixthelayout 
\usepackage{enumitem}
\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}
\usepackage{xcolor,listings}
\usepackage{textcomp}
\lstset{upquote=true}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue
}

%%% \maketitle CUSTOMISATION
% For more than trivial changes, you may as well do it yourself in a titlepage environment
\pretitle{\begin{center}\sffamily\huge\MakeUppercase}
\posttitle{\par\end{center}\vskip 0.5em}

%%% ToC (table of contents) APPEARANCE
\maxtocdepth{subsection} % include subsections
\renewcommand{\cftchapterpagefont}{}
\renewcommand{\cftchapterfont}{}     % no bold!

%%% HEADERS & FOOTERS
\pagestyle{ruled} % try also: empty , plain , headings , ruled , Ruled , companion

%%% CHAPTERS
\chapterstyle{hangnum} % try also: default , section , hangnum , companion , article, demo

\renewcommand{\chaptitlefont}{\Huge\sffamily\raggedright} % set sans serif chapter title font
\renewcommand{\chapnumfont}{\Huge\sffamily\raggedright} % set sans serif chapter number font

%%% SECTIONS
\hangsecnum % hang the section numbers into the margin to match \chapterstyle{hangnum}
\maxsecnumdepth{subsection} % number subsections

\setsecheadstyle{\Large\sffamily\raggedright} % set sans serif section font
\setsubsecheadstyle{\large\sffamily\raggedright} % set sans serif subsection font

\newlength\drop
\makeatletter
\newcommand*\titleM{\begingroup%
\setlength\drop{0.08\textheight}
\centering
\vspace*{\drop}
{\Huge\bfseries Technical Interview}\\[\baselineskip]
%{\scshape MAN-AHL}\\[\baselineskip]
\vfill
\includegraphics[width=0.6\textwidth]{img/logo.png}\par\vspace{1cm}
\vfill
{\Huge\scshape Fadil Mokhchane \\ 
\small \href{https://www.linkedin.com/in/fadil/}{LinkedIn} }\par
\vspace{1cm}
\includegraphics[width=0.3\textwidth]{img/harrington.jpg}\par
\vfill
\vspace*{2\drop}
{\scshape September 1, 2017}\par
{\scshape \small Version 1.0}\par
\endgroup}
\makeatother
%% END Memoir customization

\title{Technical Interview}
\author{Fadil Mokhchane}
%\date{ August 2017} % Delete this line to display the current date
%%% BEGIN DOCUMENT
\begin{document}


\begin{titlingpage}
\titleM
\end{titlingpage}

\newpage
\tableofcontents* % the asterisk means that the contents itself isn't put into the ToC
%\clearpage %or \cleardoublepage
\phantomsection
\listoffigures
%\listoftables
\newpage

%-------------------------------------------------------------------------------
\chapter{Algorithm Exercise}
\section{Question}
Implement the method nextNum() and a minimal but effective set of unit tests. 
Implement in the language of your choice, Python is preferred, but Java and 
other languages are completely fine. 
Make sure your code is exemplary, as if it was going to be shipped as part of a production system.

As a quick check, given Random Numbers are $[-1, 0, 1, 2, 3]$ and 
Probabilities are $[0.01, 0.3, 0.58, 0.1, 0.01]$ if we call nextNum() 100 times 
we may get the following results. As the results are random, these particular results are unlikely.
\begin{itemize}
	\item -1: 1 times 
	\item 0: 22 times
	\item 1: 57 times 
	\item 2: 20 times
	\item 3: 0 times 
\end{itemize}

\section{The Problem}
\label{sec:problem}
We interpret the question as the following the mathematical problem. 
We define a $X$ as a discrete random variable. 
As input, we have a $k$ values, $x_i$, with their associated probabilities, $p_i$.

A discrete probability density function is a probability distribution charaterised 
by a probability mass function, c.f. \autoref{eq:pdf}, referenced as PDF.
\begin{equation}
	\forall i \in \left[1 ...  k\right], P\left[ X = x_i \right] = p_i  
	\label{eq:pdf}
\end{equation}
With
\[ 
	\sum_{i = 1}^k  P\left[ X = x_i \right]  = 1
\]
The values $\left(x_i, p_i\right)$ are called the PDF pillars.
This probability mass function can be illustrated by \autoref{fig:distribution} :
\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.5\textwidth]{img/distribution.png}
\caption{Probability Mass Function}
\label{fig:distribution}
\end{center}
\end{figure}

We would like to build a generator that picks $x_i$ given their probabilities
$P_i$. 
In order to make sure we generate $x_i$ with repesct to their original probabilities, 
we need to add a no $x_i$ selected if the sum of the $x_i$ is less than $1$.

This way we can build a discrete cumulative function, referenced as CDF,
 for $X$, $F_x$, such as :
\begin{equation}
	F_x = P\left( X \leq x \right)
	\label{eq:cdf}
\end{equation}
Which can be illustrated with \autoref{fig:cdf2} :
\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.5\textwidth]{img/cdf.png}
\caption{Discrete Cumulative Distribution Function}
\label{fig:cdf2}
\end{center}
\end{figure}

We then use a bounded uniform distribution, $U\left(0,1\right)$,
to generate random numbers between $0$ and $1$.
We picked two pseudo random numbers generator : Mersenne Twister\footnote{
The Mersenne twister is a pseudorandom number generator developed by 
Makoto Matsumoto and Takuji Nishimura that is based on a matrix linear 
recurrence over a finite binary field. 
It has a period of $2^{63}-1$.
The source for the C code can be found 
\href{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html}{here}.
} (This implementation claims to be faster than Ecuyer's one.) and Ecuyer\footnote{
This is the default random number generator in haskell one in haskell.
 This implementation uses the Portable Combined Generator of L'Ecuyer
 for 32-bit computers, transliterated in Haskell by Lennart Augustsson. 
 It has a period of roughly $2.30584e18$.
 } in order to compare and pick the best one.

Finally using the inverse of the discrete cumulative function, reference as Inverse CDF, 
we can pick an $x_i$, described in \autoref{eq:invcdf}.
\begin{equation}
	\forall y \in \left[0...1 \right], F^{-1}_y = x_i
	\label{eq:invcdf}
\end{equation}
This process gives us a weighted probability pseudo random number engine.

\section{Solution Proposed}
\subsection{Overview}

The key requirement is to deliver a production quality software.
This means that the code has to be well designed, simple, 
efficient, portable and well tested.

The key features we would like to achieve :
\begin{itemize}
	\item Implement the weighted probability engine\footnote{
		The task of an engine is to manage the creation of a serie of
		pseudo random numbers.} based
		on a bounded uniform random probability engine,
	\item Target a $100\%$ testing coverage.
	\item Assess the quality of our probability engines,
	\item Assess the performances of our probability engines,
	\item Create an User Interface, via Command Line Input,
	\item Document the work.
\end{itemize}

\subsection{Design}
We target the following archictecture, c.f. \autoref{fig:architecture1}.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.8\textwidth]{img/architecture1.png}
\caption{Algorithm App Architecture}
\label{fig:architecture1}
\end{center}
\end{figure}
The various modules implement all the functionalities we need.
\begin{description}
	\item[Analytics] The mathematical functions required,
	
	In this module we have the implementation of the discrete 
	probability function\footnote{
	We can take as input incomplete probabilities, i.e. that
	don't sum up to $1$. We therefore assign the remaining
	probability to the event we don't select any element.
	Haskell provides the \emph{Maybe a} type to modelise this.
	}, the discrete cumulative function, 
	the inverse discrete cumulative function and the mean and
	standard deviation functions.
	
	\item[Uniform Engine] The bounded uniform 
	pseudo random numbers engine,
	
	This module contains an abstraction to a uniform pseudo
	random number generator with values bounded 
	within $ \left[ 0, 1 \right]$.
	It can compute a random number or a series of random 
	number and the statistics related to the distribution of 
	the random number generated.
	\item[Weighted Engine] 	The weighted pseudo random 
	numbers probability engine,
	
	This module includes an abstraction to the weighted 
	pseudo random numbers generators.
	It allows computation and statistics on these numbers.
	It includes the requested nextNum function.
	\item[CLI] 		The command line input layer,
	
	As it is meaningless to look only at one random number at the time.
	The CLI provides a flexible API to compute
	statistics on $n$ random numbers.
	We can select any random number engine we have implemented.
	We display only the distribution of these random numbers.
	\item[Testing] 	The testing module,
	
	This module provides all the automated tests. They are unit 
	tests at the module level and integration tests at the key
	features level.
\end{description}


\subsection{User Interface}
The UI is a command line input allowing the user to run each feature.
After building the project, with the following command:
\begin{verbatim}
cabal build
\end{verbatim}
The binary is then located in \emph{./dist/build/MAN-AHL/MAN-AHL}.
We can run the weighted or the uniform engine
 as described in \autoref{fig:cli}, with the following command:
\begin{verbatim}
time ./dist/build/MAN-AHL/MAN-AHL -run=Weighted -nSims=1000000
        -pillars=''
\end{verbatim}
 The binary has the option \emph{-help}, stating all the default values.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=1\textwidth]{img/cli.png}
\caption{Command Line Input}
\label{fig:cli}
\end{center}
\end{figure}


\section{Implementation}

We use Haskell as implementation language. It is a purely functional language.
It has a strong type system. It is all about types, they tell the story.
In this section, we inztroduce the key types used thoughout the application.

\subsection{Analytics Module}

The analytics are mainly destined to weighted probability engine.

We define the \emph{PieceWiseCurve x y} algebraic data type(ADT) to provide an
abstraction to piecewise curve, as we are working with discrete
random variable, it is the closest to reality. We picked the tree map data
structure, \emph{Data.Map} in Haskell, to get efficient lookup ( O(log n) ).
The \emph{Curve x y a} class\footnote{ad hoc polymorphism} 
provides the key operations on a 
\emph{PieceWiseCurve}.  

We subsequently define the ADTs to represent all the curves we need
for our weighted probability engine :
\begin{itemize}
	\item The \emph{PDF} ADT modelising the probability mass function,
	The key are the $x_i$ and the values the $p_i$, we presented in
	\autoref{sec:problem}.
	We merge the pillars with similar $x_i$, discard the pillars with zero
	$p_i$ and ensure that $\sum_i p_i \leq 1$.
	If needed we a a pillar representing non selected element 
	as \emph{Nothing}. This way we ensure that the probabilities
	adds up to 1.
	\item The \emph{CDF} ADT represents the discrete cumulative
	curve, presented in \autoref{fig:cdf2}.
	\item The \emph{InvCDF} ADT represents the inverse CDF curve,
	as explained in \autoref{eq:invcdf}
	\item The \emph{Distribution a} ADT models a distribution curve
	of the random number generated.
\end{itemize}
Again, we refer to curve as to piecewise curves or histograms.

This module contains also the basic statistics we are using to 
analyse the results.

\subsection{Uniform Engine Module}

The \emph{UniformRNG} ADT abstracts a choice of uniform pseudo random 
number generator, Mersenne Twister and Ecuyer. We could seemlessly
add new generator, if needs be. We would need to extend the standard
Haskell \emph{RandomGen} class. 
They can generate un-bounded pseudo random numbers.

The \emph{ProbaUniEngine} ADT abstracts the computation of a uniform pseudo
random number generation bounded between 0 and 1.
It uses the \emph{State} monad to pass on the state of \emph{UniformRNG}
when we combine multiple computations.
This engine instanciates the \emph{ProbaEngine} class, which define
and abstract the role of a probability engine. The latter is to 
create one or a series of pseudo random numbers.

The \emph{StatUniEngine} ADT abstracts the computation of the statistics
related to the bounded uniform random numbers generated. 
In order to be efficient, we compute only the distribution while we 
are creating pseudo random numbers. 
There is a post-processing step at the end of the simulation, which 
computes the remaining relevant statistics.
It uses the \emph{State} monad to pass on the state of the 
uniform random number generator and the cumulative statistics.
This engine instanciates the \emph{StatEngine} class, which role is
to compute the statistics of a series of random numbers.

\subsection{Weighted Engine Module}

The \emph{ProbaWPEngine} ADT allows to computed weighted pseudo
random numbers. It order to achieve this, it need to build and keep
thoughout the computations the \emph{EngineParams} ADT. 
This latter encapsulates the \emph{PDF}, \emph{CDF} and \emph{InvCDF}
ADTs. They do not change thoughout the computations and they are kept 
in memory for efficiency. We pass them thought the computations
using the \emph{Reader} monad. We also use the \emph{State} monad
to pass on the state of the bounded uniform engine.
It also instanciates the \emph{ProbaEngine} class.

The \emph{StatWPEngine} ADT compute the statistic for a weighted
probabilities run. It also use a monad composed of a \emph{Reader}
and \emph{State} monads. A post processing step computes
the remaining metrics. It also instanciates the \emph{StatEngine} class.

\subsection{CLI Module}
Using the \emph{Query} ADT we modelise a query from the command line
dynamically. This latter is processed by the \emph{run} function to 
produce a  \emph{Result} ADT.

In a way, we lose static typing here in order to merge all the types of 
request and to dispatch the query to the appropriate engine. And we merge
back the result into the \emph{Result} to provide a single function achieving
everything we need.

\subsection{Testing Module}

\section{Automated Unit and Integration Testing}
We need to test each module independtly, i.e. unit testing, and all used 
together, i.e. integration testing.

The testing environment used is described in below\footnote{
Given that I don't have access to my server, 
we run the tests on a MacBook Pro 2008 4GB DDR3 Intel Core Duo 2.53GHz.
It has 250GB harddisk, not SSD. 
We are using Haskell version 8.2.1 on MacOS. Vim version 8.0.
}.

We use heavily a random testing library, i.e. QuickCheck\footnote{
QuickCheck is a library for random testing of program properties.
The API is described 
\href{http://hackage.haskell.org/package/QuickCheck-2.10.0.1/docs/Test-QuickCheck.html}{here}.
}, to test comprehensively the software.
Automated pseudo random tests allowed to discover issues and
test cases that were not included at first.

Our test data is mostly pseudo random: 
PDF pillars, PDF, CDF and Inverse CDF inputs.

We can run the automated as described in  \autoref{fig:tests} with the command:
\begin{verbatim}
time cabal test --show-details=streaming
\end{verbatim}
\begin{figure}[h!]
\begin{center}
\includegraphics[width=1\textwidth]{img/tests.png}
\caption{Automated Testing}
\label{fig:tests}
\end{center}
\end{figure}

The following Test Suites, i.e. lists of tests, compose our test plan split by modules.

\subsection{Test Data Sample}

The key test data sample used throughout the testing 
is the generation of PDF pillars.
We tried to pick a realistic sample :
The pillars can have 1 to 10 pillars. Their summed probability are always less 
than or equal to 1.  Each probability is within the $]0, 1]$ bound.

\subsection{Analytics Testing} 
These are the unit tests for the Analytics only.
\begin{description}
	\item [CDF creation]
		Given a 1000 pseudo random PDF, we ensure 
		that the last pillar of the CDF is 1.
		As the CDF is build incrementally, this gives a good sense that
		the CDF construction has been correct.
	\item [InverseCDF, CDF and PDF pillars check]
		Given a 1000 pseudo random PDF, we ensure that
		the pillars on the x axis of the PDF and CDF are the pillars on the y
		axis of the Inverse CDF.
	\item [PDF Stable]
		Given a 1000 pseudo random PDF pillars, 
		we ensure that we get the same PDF given the reverse input.
	\item [PDF consistency]
		Given a 1000 pseudo random PDF, 
		we ensure that the sum of the PDF pillars probabilities are 
		equal to 1. We indeed modelise the non selected element
		only in the CDF.
	\item [Inverse CDF valid]
		Given a 1000 pseudo random PDF,
		we build the CDF and we ensure that for a random number of
		x values within 0 and 1 we always recover a x pillars of the PDF.
	\item [PDF failure]
		We test the expecture failure of the PDF construction. 
		We can't have negative values. We need at least one valid pillar.
		The pillars with 0 probabilities are discarded.
		And the sum of the PDF pillars probabilities must be 
		equal to one.
	\item [Inverse CDF Failure]
		We check that the inverse CDF function raise an
		exception if the x input is outside the correct bounds, 
		$\left[0, 1\right]$.
	\item [Mean and Standard Deviation Failure]
		These functions raise an exception for empty lists.
		We test it automatically.
	\item [PDF and Inverse CDF Non Regression]
		We ensure without randomness that given a set of pillars,
		we recover the expected Inverse CDF and PDF.
\end{description}
\subsection{Uniform Engine Testing} 

These are the unit tests for the bounded uniform pseudo random engine.
	
\begin{description}
	\item [Mean and Standard Deviation]
		Given a large number of random number generated for
		both Ecuyer and Mersenne, i.e. $100000$.
		We ensure that the mean and the standard deviation 
		of the distributions are still the same. Run 10 times.
		We ensure that the uniform random number engines keep
		the same properties.
	\item [Bounds]
		Test ensuring that the uniform pseudo random generators
		generate probabilities with the $[0, 1]$ bound.
		Run $10$ times for $100000$ random numbers.
	\item [Uniform]
		Ensure that the ditributions generated are uniform,
		by making sure that we match a flat distribution at 0.001
		precision.
		Run 10 times for $100000$ random numbers.
	\item [Performance]
		Ensure that the pseudo random numbers keep at
		least the same performance.
		Run 10 times for $100000$ random numbers.
\end{description}

\subsection{Weighted Engine Testing} 
These are the unit tests for the weighted pseudo random engine.
All tests are run using the two available uniform pseudo random
generators. 
These are like the integration tests as they use most of the library.
\begin{description}
	\item [Distribution check]
		We check that we recover the PDF distribution from
		a sample of 1000000 random numbers at $0.1\%$ precision.
		We run this for 10 pseudo random PDF.
	\item [Engine Fail]
		Ensure that the construction of the engine 
		handles all the expected failure.
	\item [Performance]
		Ensure that the engine keep at least the same performance.
		Run 10 times for $100000$ random  numbers	
\end{description}	

\subsection{CLI Testing}
We test that the API produce what is expected.
\begin{description}
	\item [Query]
	We test that given an argument list, we produce the expected
	Query.
	\item[Run]
	We test that for given a Query, we produce the expected Result.
\end{description}

\section{Qualitative Testing}

\section{Performance Testing}

\section{Possible Extension}
Here is a list of possible extension we could add.
\begin{description}
	\item [Analytics]
	Further abstract the PDF, CDF, InvCDF to handle all kind of keys.
	\item [Testing]
	We could run the tests on different environments to ensure the portability of 
	the code.
	\item [UI] 
	A nice extension would be to add a Graphic User Interface,
	using the library 
	\href{https://hackage.haskell.org/package/threepenny-gui}{threepenny-gui}
	to create a portable Web application. 

	Also we could integrate a plot library to display the distribution of 
	random numbers.
\end{description}

%-------------------------------------------------------------------------------
\newpage
\chapter{SQL Exercise}
\section{Question}
Given the following tables
\begin{lstlisting}[
           language=SQL,
           showspaces=false,
           basicstyle=\ttfamily,
           numbers=left,
           numberstyle=\tiny,
           commentstyle=\color{gray}
        ]
CREATE TABLE Product
(
product_id number primary key,
name varchar2(128 byte) not null,
rrp number not null,
available_from date not null
);
CREATE TABLE Orders
(
order_id number primary key,
product_id number not null,
quantity number not null,
order_price number not null,
dispatch_date date not null,
foreign key (product_id) references Product(product_id)
);
\end{lstlisting}
Write an sql query to find books that have sold fewer than 10 copies in the last year, 
excluding books that have been available for less than 1 month.

Some example data, intended to give an idea of the sort of data that might exist, 
can be found below. Note that the data is not complete, 
nor does it necessarily cover all the cases that might be encountered.

\begin{center}
    \begin{tabular}{| l | l | l | l |}
    \hline
	product\_id & name & rrp & available\_from \\
	\hline 
	101 & Bayesian Methods for ...& 94.95 & (last thursday) \\
	102 & (next year) in Review (preorder) & 21.95 & (next year) \\
	103 & Learn Python in Ten Minutes & 2.15 & (three months ago) \\
	104 & sports almanac (1999-2049) & 3.38 & (2 years ago) \\
	105 & finance for dummies & 84.99 & (1 year ago)  \\
	\hline
    \end{tabular}
\end{center}
\begin{center}
    \begin{tabular}{| l | l | l | l | l |}
    \hline
	order\_id & product\_id & quantity & order\_price & dispatch\_date \\
	\hline 
	1000 & 101 & 1 & 90.00 & (two months ago) \\
	1001 & 103 & 1 & 1.15 & (40 days ago) \\
	1002 & 101 & 10 & 90.00 & (11 months ago) \\
	1003 & 104 & 11 & 3.38 & (6 months ago) \\
	1004 & 105 & 11 & 501.33 & (two years ago) \\
	\hline
    \end{tabular}
\end{center}

\section{Solution Proposed}
We can solve the problem by running a query like:
\begin{lstlisting}[
           language=SQL,
           showspaces=false,
           basicstyle=\ttfamily,
           numbers=left,
           numberstyle=\tiny,
           commentstyle=\color{gray}
        ]
SELECT p.name
FROM  (
   SELECT product_id, name FROM Product 
      WHERE available_from <=  (today - 1 month)
) p
LEFT OUTER JOIN (
   SELECT product_id, SUM(quantity) nb FROM Orders
      WHERE dispatch_date >= (today - 1 year)
      GROUP BY product_id
      HAVING nb < 10
) o
   ON p.product_id = o.product_id
\end{lstlisting}

Adding indexes to the columns on which we join and maybe query would improve 
the performance. 
A query plan of the execution would indicate what is the best design for this 
database scheme.



%-------------------------------------------------------------------------------
\newpage
\appendix
\addcontentsline{toc}{chapter}{Appendices}

\chapter{Code} \label{apx:code}
We provide below the code.


%-------------------------------------------------------------------------------
\newpage
\chapter{Installation} \label{apx:installation}

Here are the steps to install the App.
\begin{enumerate}
	\item Download Haskell via this \href{https://www.haskell.org/platform/}{link}.
	\item Install following the instructions given by the installer.
	\item Use cabal to download the require packages :
\begin{lstlisting}[
           language=SQL,
           showspaces=false,
           basicstyle=\ttfamily,
           numbers=left,
           numberstyle=\tiny,
           commentstyle=\color{gray}
        ]
	cabal install TBC
\end{lstlisting}
\end{enumerate}
\end{document}
